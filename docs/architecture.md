# Architecture: Interactive Data Viz Orchestrator

## 1. High-Level Overview

A full-stack application using **Next.js** for the interactive "Artifact" frontend and **FastAPI** for the heavy-lifting data logic and LLM orchestration.

## 2. Tech Stack

* **Frontend:** Next.js 15, Tailwind CSS, Shadcn UI.
* **Backend:** FastAPI (Python 3.11+).
* **AI Integration:** LangChain or PydanticAI (within FastAPI) for tool-calling.
* **Communication:**
    * **REST:** For standard CRUD and template saving.
    * **SSE (Server-Sent Events):** For streaming AI thoughts and UI code chunks.
* **Data Execution**:  (already provided by external services)
    * **Local DuckDB**: for debugging purposes
    * **Distributed DuckDB:** For immediate "Small Subset" SQL execution.
    * **PySpark:** For submitting jobs to remote Spark clusters.

## 3. System Components

### A. FastAPI Orchestrator (`/backend`)
* **Agent Logic:** Uses PydanticAI to define "Tools" (e.g., `run_sql`, `submit_spark`).
* **Artifact Generator:** A specialized endpoint `/generate-ui` that streams back React code blocks.
* **Data Proxy:** Acts as a secure gateway to your Spark/SQL clusters.

### B. Next.js Frontend (`/frontend`)
* **Artifact Processor:** Uses `fetch` with a `ReadableStream` to consume FastAPI's SSE stream.
* **Dynamic Renderer:** `react-runner` to mount the code generated by the Python backend.

## 4. Directory Structure
```text
├── frontend/             # Next.js App
│   ├── components/       # Chat and Preview Sandbox
│   └── lib/              # API clients for FastAPI
├── backend/              # FastAPI App
│   ├── api/              # Routes (chat, data, templates)
│   ├── agents/           # LLM logic & PydanticAI tools
│   ├── core/             # Spark/SQL connection logic
│   └── main.py           # Entry point
├── docs/                 # Architecture & Requirements
└── .cursor/rules/        # Agent instructions
```

## 5. SSE Streaming Format Specification

The `/chat` endpoint streams structured events using Server-Sent Events. Each event follows this format:

```
event: <event_type>
data: <json_payload>
```

### Event Types:

**`thought`** - LLM reasoning/thinking process
```json
{
  "type": "thinking",
  "content": "Analyzing your request..."
}
```

**`code`** - UI code chunks (streamed incrementally)
```json
{
  "type": "code_chunk",
  "language": "tsx",
  "content": "import React from 'react';..."
}
```

**`data`** - Data ready notification
```json
{
  "type": "data_ready",
  "url": "/api/data/abc123",
  "size": "small" | "large",
  "format": "json" | "parquet"
}
```

**`error`** - Error occurred during processing
```json
{
  "type": "error",
  "message": "SQL execution failed",
  "stage": "sql_execution" | "code_generation" | "data_fetch"
}
```

**`done`** - Stream complete
```json
{
  "type": "complete",
  "code_complete": true,
  "data_ready": true
}
```

## 6. Parameterization Timing & Behavior

### States:
- **During Streaming:** Parameter controls are disabled, show "Generating..." indicator
- **After Completion:** Parameter controls are enabled, allow real-time UI updates
- **Re-rendering:** When parameters change, re-render the component with new `params` prop **without** re-querying data

### Implementation:
- Debounce parameter changes (300ms) to avoid excessive re-renders
- Maintain separate state for: `isGenerating`, `generatedCode`, `currentParams`, `dataUrl`
- Parameter changes trigger component re-mount with updated `params` prop only

## 7. Template Format Schema

Templates are stored as JSON objects with the following structure:

```json
{
  "id": "uuid-v4",
  "prompt": "Show sales by region",
  "generated_sql": "SELECT region, SUM(sales) FROM ...",
  "ui_code": "export default function Viz({ data, params }) {...}",
  "parameters": {
    "title": "Sales by Region",
    "chart_type": "bar",
    "color_scheme": "default"
  },
  "data_source": "spark" | "duckdb",
  "data_url": "/api/data/abc123" | null,
  "created_at": "2024-01-01T00:00:00Z",
  "updated_at": "2024-01-01T00:00:00Z"
}
```

**Storage:** Backend persists templates in Postgres. Frontend can load templates via REST API.

## 8. Type Safety & Schema Alignment

### Backend (Pydantic):
- All API responses use Pydantic v2 models
- Tool definitions (run_sql, submit_spark) use Pydantic BaseModel
- Query results typed as `QueryResult` model with `columns: List[str]` and `rows: List[List[Any]]`

### Frontend (TypeScript/Zod):
- Generate TypeScript types from Pydantic models using `pydantic-to-typescript` or manual type definitions
- Validate incoming data with Zod schemas before passing to Sandbox
- Shared type definitions in `/frontend/lib/types.ts`

### Type Generation Strategy:
1. Define Pydantic models in `/backend/models/`
2. Export JSON schemas: `model.model_json_schema()`
3. Generate TypeScript interfaces from schemas (or manually maintain)
4. Create corresponding Zod schemas for runtime validation

## 9. Development Standards
Modular UI: Generated code must be a default export: `export default function Viz({ data, params }) { ... }`.

Data Safety: All data results must be typed via Zod before being passed to the Sandbox.

Templates: Conversation state (Prompt + Generated Code + Params) is stored as a JSON object for sharing.
